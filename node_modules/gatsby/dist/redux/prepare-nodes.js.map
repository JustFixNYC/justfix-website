{"version":3,"sources":["../../src/redux/prepare-nodes.js"],"names":["_","require","trackInlineObjectsInRootNode","store","getNullableType","getNamedType","withResolverContext","enhancedNodeCache","Map","enhancedNodePromiseCache","enhancedNodeCacheId","node","args","internal","contentDigest","JSON","stringify","nodeid","id","digest","awaitSiftField","fields","k","field","resolve","schema","schemaCustomization","getState","context","fieldName","returnType","type","undefined","resolveRecursive","siftFieldsObj","gqFields","Promise","all","keys","map","then","v","innerSift","innerGqConfig","innerType","innerListType","isObject","isFunction","getFields","isArray","item","resolvedFields","myNode","forEach","resolveNodes","nodes","typeName","firstOnly","fieldsToSift","gqlFields","resolvedNodesCache","nodesCacheKey","nodesLength","length","has","get","cacheKey","enhancedNodeGenerationPromise","resolvedNode","set","resolvedNodes","dispatch","payload","key","module","exports"],"mappings":"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","sourcesContent":["const _ = require(`lodash`)\nconst { trackInlineObjectsInRootNode } = require(`../db/node-tracking`)\nconst { store } = require(`../redux`)\nconst { getNullableType, getNamedType } = require(`graphql`)\nconst withResolverContext = require(`../schema/context`)\n\nconst enhancedNodeCache = new Map()\nconst enhancedNodePromiseCache = new Map()\nconst enhancedNodeCacheId = ({ node, args }) =>\n  node && node.internal && node.internal.contentDigest\n    ? JSON.stringify({\n        nodeid: node.id,\n        digest: node.internal.contentDigest,\n        ...args,\n      })\n    : null\n\n/////////////////////////////////////////////////////////////////////\n// Resolve nodes\n/////////////////////////////////////////////////////////////////////\n\nfunction awaitSiftField(fields, node, k) {\n  const field = fields[k]\n  if (field.resolve) {\n    const { schema, schemaCustomization } = store.getState()\n    return field.resolve(\n      node,\n      {},\n      withResolverContext({}, schema, schemaCustomization.context),\n      {\n        fieldName: k,\n        schema,\n        returnType: field.type,\n      }\n    )\n  } else if (node[k] !== undefined) {\n    return node[k]\n  }\n\n  return undefined\n}\n\n// Resolves every field used in the node.\nfunction resolveRecursive(node, siftFieldsObj, gqFields) {\n  return Promise.all(\n    _.keys(siftFieldsObj).map(k =>\n      Promise.resolve(awaitSiftField(gqFields, node, k))\n        .then(v => {\n          const innerSift = siftFieldsObj[k]\n          const innerGqConfig = gqFields[k]\n\n          const innerType = getNullableType(innerGqConfig.type)\n          const innerListType = getNamedType(innerType)\n          if (_.isObject(innerSift) && v != null && innerType) {\n            if (_.isFunction(innerType.getFields)) {\n              // this is single object\n              return resolveRecursive(v, innerSift, innerType.getFields())\n            } else if (_.isArray(v) && _.isFunction(innerListType.getFields)) {\n              // this is array\n              return Promise.all(\n                v.map(item =>\n                  resolveRecursive(item, innerSift, innerListType.getFields())\n                )\n              )\n            }\n          }\n\n          return v\n        })\n        .then(v => [k, v])\n    )\n  ).then(resolvedFields => {\n    const myNode = {\n      ...node,\n    }\n    resolvedFields.forEach(([k, v]) => (myNode[k] = v))\n    return myNode\n  })\n}\n\nfunction resolveNodes(nodes, typeName, firstOnly, fieldsToSift, gqlFields) {\n  const { resolvedNodesCache } = store.getState()\n  const nodesCacheKey = JSON.stringify({\n    // typeName + count being the same is a pretty good\n    // indication that the nodes are the same.\n    typeName,\n    firstOnly,\n    nodesLength: nodes.length,\n    ...fieldsToSift,\n  })\n  if (resolvedNodesCache.has(nodesCacheKey)) {\n    return Promise.resolve(resolvedNodesCache.get(nodesCacheKey))\n  } else {\n    return Promise.all(\n      nodes.map(node => {\n        const cacheKey = enhancedNodeCacheId({\n          node,\n          args: fieldsToSift,\n        })\n        if (cacheKey && enhancedNodeCache.has(cacheKey)) {\n          return Promise.resolve(enhancedNodeCache.get(cacheKey))\n        } else if (cacheKey && enhancedNodePromiseCache.has(cacheKey)) {\n          return enhancedNodePromiseCache.get(cacheKey)\n        }\n\n        const enhancedNodeGenerationPromise = new Promise(resolve => {\n          resolveRecursive(node, fieldsToSift, gqlFields).then(resolvedNode => {\n            trackInlineObjectsInRootNode(resolvedNode)\n            if (cacheKey) {\n              enhancedNodeCache.set(cacheKey, resolvedNode)\n            }\n            resolve(resolvedNode)\n          })\n        })\n        enhancedNodePromiseCache.set(cacheKey, enhancedNodeGenerationPromise)\n        return enhancedNodeGenerationPromise\n      })\n    ).then(resolvedNodes => {\n      store.dispatch({\n        type: `SET_RESOLVED_NODES`,\n        payload: {\n          key: nodesCacheKey,\n          nodes: resolvedNodes,\n        },\n      })\n      return resolvedNodes\n    })\n  }\n}\n\nmodule.exports = {\n  resolveNodes,\n  resolveRecursive,\n}\n"],"file":"prepare-nodes.js"}